-- Chat enhancements: typing signals, read receipts, structured attachments

-- Add sender_display_name column for legacy rows and future inserts
ALTER TABLE public.messages
  ADD COLUMN IF NOT EXISTS sender_display_name text;

-- Track read/delivery receipts per participant
CREATE TABLE IF NOT EXISTS public.message_receipts (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  message_id uuid NOT NULL REFERENCES public.messages(id) ON DELETE CASCADE,
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  receipt_type text NOT NULL CONSTRAINT message_receipts_type_check CHECK (receipt_type IN ('delivered','read')),
  created_at timestamptz NOT NULL DEFAULT now(),
  UNIQUE (message_id, user_id, receipt_type)
);

ALTER TABLE public.message_receipts ENABLE ROW LEVEL SECURITY;

DO $$ BEGIN
  CREATE POLICY "message_receipts_participants" ON public.message_receipts
    FOR ALL USING (
      EXISTS (
        SELECT 1 FROM public.conversation_participants cp
        JOIN public.messages m ON m.id = message_id
        WHERE cp.conversation_id = m.conversation_id AND cp.user_id = auth.uid()
      )
    ) WITH CHECK (
      EXISTS (
        SELECT 1 FROM public.messages m
        JOIN public.conversation_participants cp ON cp.conversation_id = m.conversation_id
        WHERE m.id = message_id AND cp.user_id = auth.uid()
      )
    );
EXCEPTION WHEN duplicate_object THEN NULL; END $$;

-- Store structured attachment metadata tied to storage objects
CREATE TABLE IF NOT EXISTS public.message_attachments (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  message_id uuid NOT NULL REFERENCES public.messages(id) ON DELETE CASCADE,
  bucket_id text NOT NULL DEFAULT 'chat-attachments',
  object_path text NOT NULL,
  file_name text,
  mime_type text,
  file_size_bytes bigint,
  created_at timestamptz NOT NULL DEFAULT now()
);

ALTER TABLE public.message_attachments ENABLE ROW LEVEL SECURITY;

DO $$ BEGIN
  CREATE POLICY "message_attachments_participants" ON public.message_attachments
    FOR ALL USING (
      EXISTS (
        SELECT 1 FROM public.messages m
        JOIN public.conversation_participants cp ON cp.conversation_id = m.conversation_id
        WHERE m.id = message_id AND cp.user_id = auth.uid()
      )
    ) WITH CHECK (
      EXISTS (
        SELECT 1 FROM public.messages m
        JOIN public.conversation_participants cp ON cp.conversation_id = m.conversation_id
        WHERE m.id = message_id AND cp.user_id = auth.uid()
      )
    );
EXCEPTION WHEN duplicate_object THEN NULL; END $$;

CREATE INDEX IF NOT EXISTS message_attachments_message_id_idx ON public.message_attachments(message_id);

-- Ephemeral typing indicators persisted for observability/debugging
CREATE TABLE IF NOT EXISTS public.typing_events (
  conversation_id uuid NOT NULL REFERENCES public.conversations(id) ON DELETE CASCADE,
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  expires_at timestamptz NOT NULL DEFAULT (now() + interval '6 seconds'),
  PRIMARY KEY (conversation_id, user_id)
);

ALTER TABLE public.typing_events ENABLE ROW LEVEL SECURITY;

DO $$ BEGIN
  CREATE POLICY "typing_events_participants" ON public.typing_events
    FOR ALL USING (
      EXISTS (
        SELECT 1 FROM public.conversation_participants cp
        WHERE cp.conversation_id = typing_events.conversation_id AND cp.user_id = auth.uid()
      )
    ) WITH CHECK (
      EXISTS (
        SELECT 1 FROM public.conversation_participants cp
        WHERE cp.conversation_id = typing_events.conversation_id AND cp.user_id = auth.uid()
      ) AND auth.uid() = user_id
    );
EXCEPTION WHEN duplicate_object THEN NULL; END $$;

CREATE INDEX IF NOT EXISTS typing_events_expires_at_idx ON public.typing_events(expires_at);

-- Utility to keep typing_events tidy
CREATE OR REPLACE FUNCTION public.auto_expire_typing_events()
RETURNS trigger AS $$
BEGIN
  DELETE FROM public.typing_events WHERE expires_at < now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS typing_events_cleaner ON public.typing_events;
CREATE TRIGGER typing_events_cleaner
AFTER INSERT ON public.typing_events
EXECUTE FUNCTION public.auto_expire_typing_events();
