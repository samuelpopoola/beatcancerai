-- Conversations table holds patient-clinician threads
create table if not exists public.conversations (
  id uuid primary key default gen_random_uuid(),
  status text not null default 'open',
  urgency text not null default 'routine',
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  last_message_at timestamptz,
  created_by uuid not null references auth.users(id),
  metadata jsonb default '{}'::jsonb
);

-- Participants for each conversation (patient, clinician, care coordinator, etc.)
create table if not exists public.conversation_participants (
  conversation_id uuid references public.conversations(id) on delete cascade,
  user_id uuid references auth.users(id) on delete cascade,
  role text not null check (role in ('patient','clinician','care_coordinator','support')),
  is_primary boolean not null default false,
  notification_prefs jsonb default '{}'::jsonb,
  joined_at timestamptz not null default now(),
  primary key (conversation_id, user_id)
);

-- Ensure legacy tables pick up the new columns/constraints
alter table public.conversation_participants
  add column if not exists conversation_id uuid references public.conversations(id) on delete cascade,
  add column if not exists user_id uuid references auth.users(id) on delete cascade,
  add column if not exists role text,
  add column if not exists is_primary boolean default false,
  add column if not exists notification_prefs jsonb default '{}'::jsonb,
  add column if not exists joined_at timestamptz default now();

alter table public.conversation_participants
  alter column role set not null;

do $$ begin
  alter table public.conversation_participants
    add constraint conversation_participants_role_check
      check (role in ('patient','clinician','care_coordinator','support'));
exception when duplicate_object then null; end $$;

do $$ begin
  if not exists (
    select 1 from pg_constraint
    where conrelid = 'public.conversation_participants'::regclass
      and contype = 'p'
  ) then
    alter table public.conversation_participants
      add primary key (conversation_id, user_id);
  end if;
end $$;

alter table public.conversation_participants enable row level security;

create table if not exists public.messages (
  id uuid primary key default gen_random_uuid(),
  conversation_id uuid not null references public.conversations(id) on delete cascade,
  sender_id uuid not null references auth.users(id) on delete cascade,
  content text,
  message_type text not null default 'text',
  attachment_manifest jsonb,
  ai_metadata jsonb,
  read_at timestamptz,
  delivered_at timestamptz,
  created_at timestamptz not null default now()
);

alter table public.messages
  add column if not exists conversation_id uuid references public.conversations(id) on delete cascade,
  add column if not exists sender_id uuid references auth.users(id) on delete cascade;

alter table public.messages enable row level security;
create index if not exists messages_conversation_id_idx on public.messages(conversation_id, created_at);

create table if not exists public.message_templates (
  id uuid primary key default gen_random_uuid(),
  title text not null,
  content text not null,
  category text,
  for_doctor boolean not null default true,
  created_by uuid references auth.users(id),
  tags text[] default '{}',
  created_at timestamptz not null default now()
);

create table if not exists public.message_bookmarks (
  id uuid primary key default gen_random_uuid(),
  message_id uuid not null references public.messages(id) on delete cascade,
  user_id uuid not null references auth.users(id) on delete cascade,
  note text,
  created_at timestamptz not null default now()
);

create table if not exists public.call_sessions (
  id uuid primary key default gen_random_uuid(),
  conversation_id uuid not null references public.conversations(id) on delete cascade,
  scheduled_for timestamptz,
  status text not null default 'scheduled',
  daily_room_name text,
  daily_room_url text,
  daily_token text,
  consent_status text default 'pending',
  summary jsonb,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

alter table public.call_sessions
  add column if not exists conversation_id uuid references public.conversations(id) on delete cascade;

create table if not exists public.call_participants (
  call_id uuid references public.call_sessions(id) on delete cascade,
  user_id uuid references auth.users(id) on delete cascade,
  role text,
  joined_at timestamptz,
  left_at timestamptz,
  consented boolean default false,
  primary key (call_id, user_id)
);

create table if not exists public.communication_audit (
  id bigint generated by default as identity primary key,
  user_id uuid,
  conversation_id uuid,
  call_id uuid,
  action text not null,
  payload jsonb,
  created_at timestamptz not null default now()
);

alter table public.communication_audit
  add column if not exists conversation_id uuid;

-- Enable row level security and policies
alter table public.conversations enable row level security;
alter table public.message_templates enable row level security;
alter table public.message_bookmarks enable row level security;
alter table public.call_sessions enable row level security;
alter table public.call_participants enable row level security;
alter table public.communication_audit enable row level security;

-- Participants can read/insert conversations they belong to
do $$ begin
  create policy "conversations_select" on public.conversations
    for select using (
      exists (
        select 1 from public.conversation_participants cp
        where cp.conversation_id = conversations.id
          and cp.user_id = auth.uid()
      )
    );
exception when duplicate_object then null; end $$;

do $$ begin
  create policy "conversations_insert" on public.conversations
    for insert with check ( auth.uid() = created_by );
exception when duplicate_object then null; end $$;

do $$ begin
  create policy "conversations_update" on public.conversations
    for update using (
      exists (
        select 1 from public.conversation_participants cp
        where cp.conversation_id = conversations.id
          and cp.user_id = auth.uid()
      )
    );
exception when duplicate_object then null; end $$;

do $$ begin
  create policy "participants_select" on public.conversation_participants
    for select using (
      conversation_id in (
        select conversation_id from public.conversation_participants
        where user_id = auth.uid()
      )
    );
exception when duplicate_object then null; end $$;

do $$ begin
  create policy "participants_insert" on public.conversation_participants
    for insert with check ( auth.uid() = user_id );
exception when duplicate_object then null; end $$;

do $$ begin
  create policy "participants_delete" on public.conversation_participants
    for delete using ( user_id = auth.uid() );
exception when duplicate_object then null; end $$;

do $$ begin
  create policy "messages_select" on public.messages
    for select using (
      exists (
        select 1 from public.conversation_participants cp
        where cp.conversation_id = messages.conversation_id
          and cp.user_id = auth.uid()
      )
    );
exception when duplicate_object then null; end $$;

do $$ begin
  create policy "messages_insert" on public.messages
    for insert with check (
      sender_id = auth.uid() and
      exists (
        select 1 from public.conversation_participants cp
        where cp.conversation_id = messages.conversation_id
          and cp.user_id = auth.uid()
      )
    );
exception when duplicate_object then null; end $$;

do $$ begin
  create policy "messages_update" on public.messages
    for update using (
      sender_id = auth.uid()
      or exists (
        select 1 from public.conversation_participants cp
        where cp.conversation_id = messages.conversation_id
          and cp.user_id = auth.uid()
      )
    );
exception when duplicate_object then null; end $$;

do $$ begin
  create policy "templates_select" on public.message_templates
    for select using ( true );
exception when duplicate_object then null; end $$;

do $$ begin
  create policy "templates_insert" on public.message_templates
    for insert with check ( auth.uid() = created_by );
exception when duplicate_object then null; end $$;

do $$ begin
  create policy "bookmarks_select" on public.message_bookmarks
    for select using ( user_id = auth.uid() );
exception when duplicate_object then null; end $$;

do $$ begin
  create policy "bookmarks_rw" on public.message_bookmarks
    for all using ( user_id = auth.uid() ) with check ( user_id = auth.uid() );
exception when duplicate_object then null; end $$;

do $$ begin
  create policy "calls_select" on public.call_sessions
    for select using (
      exists (
        select 1 from public.conversation_participants cp
        where cp.conversation_id = call_sessions.conversation_id
          and cp.user_id = auth.uid()
      )
    );
exception when duplicate_object then null; end $$;

do $$ begin
  create policy "calls_insert" on public.call_sessions
    for insert with check (
      exists (
        select 1 from public.conversation_participants cp
        where cp.conversation_id = call_sessions.conversation_id
          and cp.user_id = auth.uid()
      )
    );
exception when duplicate_object then null; end $$;

do $$ begin
  create policy "calls_update" on public.call_sessions
    for update using (
      exists (
        select 1 from public.conversation_participants cp
        where cp.conversation_id = call_sessions.conversation_id
          and cp.user_id = auth.uid()
      )
    );
exception when duplicate_object then null; end $$;

do $$ begin
  create policy "call_participants_all" on public.call_participants
    for all using (
      exists (
        select 1 from public.conversation_participants cp
        join public.call_sessions cs on cs.id = call_id
        where cp.conversation_id = cs.conversation_id
          and cp.user_id = auth.uid()
      )
    ) with check (
      exists (
        select 1 from public.conversation_participants cp
        join public.call_sessions cs on cs.id = call_id
        where cp.conversation_id = cs.conversation_id
          and cp.user_id = auth.uid()
      )
    );
exception when duplicate_object then null; end $$;

do $$ begin
  create policy "audit_insert" on public.communication_audit
    for insert with check ( true );
exception when duplicate_object then null; end $$;

do $$ begin
  create policy "audit_select" on public.communication_audit
    for select using (
      auth.jwt() ->> 'role' in ('clinician','admin')
    );
exception when duplicate_object then null; end $$;

-- Storage buckets for chat attachments, avatars, call recordings
insert into storage.buckets (id, name, public)
values ('chat-attachments','chat-attachments', false)
on conflict (id) do nothing;

insert into storage.buckets (id, name, public)
values ('profile-avatars','profile-avatars', false)
on conflict (id) do nothing;

insert into storage.buckets (id, name, public)
values ('call-recordings','call-recordings', false)
on conflict (id) do nothing;

-- Allow participants to manage chat attachments
do $$ begin
  create policy "chat-attachments-read" on storage.objects
    for select using (
      bucket_id = 'chat-attachments' and
      (auth.role() = 'authenticated')
    );
exception when duplicate_object then null; end $$;

do $$ begin
  create policy "chat-attachments-insert" on storage.objects
    for insert with check (
      bucket_id = 'chat-attachments' and auth.role() = 'authenticated'
    );
exception when duplicate_object then null; end $$;

-- Avatar policies
do $$ begin
  create policy "avatars-read" on storage.objects
    for select using (
      bucket_id = 'profile-avatars'
    );
exception when duplicate_object then null; end $$;

do $$ begin
  create policy "avatars-insert" on storage.objects
    for insert with check (
      bucket_id = 'profile-avatars' and auth.uid()::text = split_part(name, '/', 1)
    );
exception when duplicate_object then null; end $$;

-- Call recording policies
do $$ begin
  create policy "call-recordings-read" on storage.objects
    for select using (
      bucket_id = 'call-recordings' and auth.role() = 'authenticated'
    );
exception when duplicate_object then null; end $$;

do $$ begin
  create policy "call-recordings-insert" on storage.objects
    for insert with check (
      bucket_id = 'call-recordings' and auth.role() = 'authenticated'
    );
exception when duplicate_object then null; end $$;
